<!doctype html>
<html>

<head>
	<meta charset="utf-8" />
	<title>SimRel | Documentation</title>
	<link rel="preconnect stylesheet" href="project.css" />
	<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/marked/lib/marked.umd.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/marked-gfm-heading-id/lib/index.umd.js"></script>
	<script src="project.js"></script>
	<style>
		/* <![CDATA[*/

		img {
			max-width: 100%;
		}

		th,
		td {
			border: 1px solid black;
			padding: 0.2ex 1em;
		}

		th {
			text-align: center;
		}

		td {
			text-align: left;
		}

		tr:nth-child(2n) {
			background-color: seashell;
		}

		li p {
			margin: 0;
		}

		table {
			border: 1px solid black;
			border-collapse: collapse;
			margin-bottom: 2ex;
		}

		#table-of-contents {
			padding: 0;
			margin: 0;
			margin-left: 0.5em;
		}

		.tl1 {
			margin-left: 0em;
			font-size: 90%;
		}

		.tl2 {
			margin-left: 0.5em;
			font-size: 85%;
		}

		.tl3 {
			margin-left: 1.0em;
			font-size: 80%;
		}

		.tl4 {
			margin-left: 1.5em;
			font-size: 75%;
		}

		.tl5 {
			margin-left: 2.0em;
			font-size: 75%;
		}

		.tl6 {
			margin-left: 2.5em;
			font-size: 75%;
		}

		#toc {
			float: right;
			position: sticky;
			top: 0;
			margin-top: 1.5em;
		}

		#toc .sideitem {
			padding: 0.5em 0.5em;
			margin-bottom: 0;
		}

		#toc h2 {
			margin-bottom: 0.5em;
			padding-bottom: 0.0em;
		}

		#toc #table-of-contents {
			max-height: 66vh;
			overflow-y: auto;
		}

		details>summary {
			margin-bottom: 0.5em;
		}

		details>summary::before {
			content: '▷️ ';
			color: orange;
		}

		details[open]>summary::before {
			content: '◢ ';
			color: orange;
		}

		:target {
			border-style: solid;
			border-width: 1px;
		}

		#edit-markdown-link {
			display: block;
			margin-bottom: 1em;
		}

		/*]]>*/
	</style>
</head>

<body>
	<div data-generate="generateDefaultBreadcrumb(this)">
		<a href=".">SimRel</a>
	</div>

	<div data-generate="generateDefaults(this)">
	</div>

	<main>
		<div id="markdown-target"></div>
	</main>

	<script>
		//<![CDATA[

		function getFileParameter() {
			const search = new URLSearchParams(window.location.search);
			return search.get('file') ?? 'profile/README.md';
		}

		function getMarkdownSearch(path) {
			const dotGitHubParts = /eclipse-simrel\/.github\/main\/(?<path>.*)/.exec(path);
			if (dotGitHubParts != null) {
				return `?file=${dotGitHubParts.groups.path}`;
			}
			return `?file=${path}`;
		}

		function getMarkdownURL(path) {
			const parts = /^eclipse-simrel\/simrel-webiste\/main(.*)/.exec(path);
			if (parts == null) {
				return `${markdownBase}${path}`;
			}
			return `${selfHostedMarkdownBase}${parts[1].replace(/^\//, '')}`;
		}

		const file = getFileParameter();
		const dotGitHub = /(?<root>wiki|profile)\/(?<path>.*)/.exec(file);
		const parts = /(?<org>eclipse-packaging)\/(?<repo>[^/]+)\/(?<branch>[^/]+)\/(?<path>.*)/.exec(file);
		const org = parts != null ? parts.groups.org : 'eclipse-simrel';
		const repo = parts != null ? parts.groups.repo : dotGitHub == null ? 'simrel-website' : '.github';
		const branch = parts != null ? parts.groups.branch : 'main';
		const path = parts != null ? parts.groups.path : dotGitHub == null ? file : `${dotGitHub.groups.root}/${dotGitHub.groups.path}`;

		const isLocalHost = window.location.hostname == 'localhost';
		const selfHosted = repo == 'simrel-website';
		const repoName = dotGitHub == null ? 'SimRel' : 'SimRel Wiki';

		tableOfContentsAside = `
<div id="toc" class="col-md-6">
	<aside>
		<ul class="ul-left-nav">
			<div  class="sideitem">
				<h2>Table of Contents</h2>
				<div id="toc-target">
				</div>
			</div>
		</ul>
	</aside>
</div>`;

		generate();

		if (org == 'eclipse-packaging') {
			const headerNavImg = document.getElementById('header-nav-img');
			if (headerNavImg != null) {
				headerNavImg.src = 'https://raw.githubusercontent.com/eclipse-packaging/.github/refs/heads/main/assets/artwork/svg/EPP-Color-Vertical.svg';
			}
		}

		const targetElement = document.getElementById('markdown-target');

		function fixHash(hash) {
			return hash.toLowerCase();
		}

		function toSiteURL(url) {
			if (url.hostname == 'api.github.com' && url.pathname.startsWith('/repos/eclipse-simrel/simrel-website/contents')) {
				const result = new URL(window.location);
				result.pathname = url.pathname.replace(/\/repos\/eclipse-simrel\/simrel-website\/contents/, '/simrel')
				result.hash = url.hash;
				result.search = url.search;
				return result;
			} else {
				return null;
			}
		}

		function generateBreadcrumbDetails(path) {
			const breadcrumb = document.querySelector(".breadcrumb");
			if (path.startsWith('report/report.md')) {
				document.title = `SimRel | Participants`;
				breadcrumb.append(...toElements(`<li>Participants</li>`));
			} else if (path.startsWith('wiki/Simultaneous_Release.md')) {
				document.title = `SimRel | Schedule`;
				breadcrumb.append(...toElements(`<li>Schedule</li>`));
			} else {
				const matchRelease = /^wiki\/SimRel\/(?<name>[0-9-]+).md$/.exec(path);
				if (matchRelease != null) {
					const name = matchRelease.groups.name;
					breadcrumb.append(...toElements(`<li><a href="${scriptBase}?file=wiki/Simultaneous_Release.md">Schedule</a></li> <li>${name}</li>`));
					document.title = `SimRel | ${name}`;
				} else {
					const matchBasic = /^wiki\/SimRel\/(?<qualifier>Simultaneous_Release_Cycle_|Simultaneous_Release_|Contributing_to_Simrel_Aggregation_Build|Release_|)(?<name>.*).md$/.exec(path);
					if (matchBasic != null) {
						const name = niceName(matchBasic.groups.name);
						const fixedName = name == '' ? 'Contibution' : name;
						breadcrumb.append(...toElements(`<li>${fixedName}</li>`));
						document.title = `SimRel | ${fixedName}`;
					} else {
						const participantMatch = /^wiki\/SimRel\/(?<name>.*)_participants.json$/.exec(path);
						if (participantMatch != null) {
							const name = `${participantMatch.groups.name} Participants`;
							document.title = `SimRel | ${name}`;
							breadcrumb.append(...toElements(`<li>${name}</li>`));
						}
					}
				}
			}
		}

		function generateFileList(files) {
			const fileElements = files.map(file => {
				const fileURL = new URL(file.url);
				const fileName = fileURL.pathname.endsWith('/profile') || fileURL.pathname.endsWith('/') || isLocalHost && file['type'] == 'dir' ?
					/(?<filename>[^./][^/]+)\/?$/.exec(fileURL.pathname) :
					/(?<filename>[^/]+)\.(md|json)$/.exec(fileURL.pathname);
				if (fileName == null) {
					return '';
				}
				const branch = fileURL.searchParams.get('ref');
				const parts = /\/repos\/(?<org>[^/]+)\/(?<repo>[^/]+)\/contents\/(?<path>.*)/.exec(fileURL.pathname);
				const url = new URL(window.location);
				url.hash = '';
				url.search = getMarkdownSearch(`${parts.groups.org}/${parts.groups.repo}/${branch}/${parts.groups.path}`.replace('//', '/'));
				const label = niceName(fileName.groups.filename);
				return `<div><a href="${url}">${label}<a/></div>\n`;
			});

			const folder = path.replace(/\/$/, '');
			const heading = `<h2>Contents of ${org}/${repo}${folder.length == 0 ? '' : ` - ${folder}`}</h2>\n`;

			targetElement.innerHTML = heading + fileElements.join('');
		}

		function generateReleaseParticipants(logicalBaseURL, response) {
			const json = JSON.parse(response);
			const release = Object.keys(json);
			const projects = json[release].projects;
			const projectList = Object.entries(projects).map(([key, value]) => {
				const project_name = value.project_name;
				const new_and_noteworthy_url = value.new_and_noteworthy_url;
				const news = new_and_noteworthy_url == null ? '' : ` [&#128240;](${new_and_noteworthy_url})`;
				return `1. [${project_name}](https://projects.eclipse.org/projects/${key})${news}`;
			}).join('\n');
			generateMarkdown(logicalBaseURL, `
# [${release}](${release}.md)

${projectList}

<details>
<summary>${release}_participants.json</summary>

${"```"}
${response}
${"```"}
</details>
`)
		}

		function generateMarkdown(logicalBaseURL, response) {
			if (response instanceof Array) {
				generateFileList(response);
			} else if (response.startsWith('{')) {
				if (logicalBaseURL.toString().endsWith("_participants.json")) {
					generateReleaseParticipants(logicalBaseURL, response);
				} else {
					generateMarkdown(logicalBaseURL, `
${"```"}
${response}
${"```"}
`);
				}
			} else {
				const text = response;
				const editLink = logicalBaseURL.toString().includes('report.md') ? '' : `<a id="edit-markdown-link" href=""><span class="orange">\u270E Improve this page</span></a>\n`;
				marked.use(markedGfmHeadingId.gfmHeadingId());
				marked.use({
					hooks: {
						postprocess(html) {
							return `${html}`;
						}
					}
				});
				targetElement.innerHTML = editLink + marked.parse(text);

				const headings = markedGfmHeadingId.getHeadingList();
				const headingText = `
<ul id="table-of-contents">
${headings.map(({id, raw, level}) => `<li class="tl${level}"><a href="#${id}">${raw}</a></li>`).join(' ')}
</ul>
`;
				document.getElementById('toc-target').replaceChildren(...toElements(headingText));

				const logo = targetElement.querySelector('img[src$="SimRel-Color.svg"]');
				if (logo != null) {
					const next = logo.nextElementSibling
					logo.remove();
					if (next != null) {
						next.remove();
					}
				}

				const imgs = targetElement.querySelectorAll("img[src]");
				for (const img of imgs) {
					const src = img.getAttribute('src');
					if (src == null) {
						continue;
					}

					if (!src.startsWith('http')) {
						const logicalSrc = new URL(src, logicalBaseURL);
						const siteURL = toSiteURL(logicalSrc);
						if (siteURL != null) {
							img.src = siteURL;
						} else {
							img.src = new URL(`https://raw.githubusercontent.com/${org}/${repo}/${branch}/${path}/../${src}`);
						}
					}
				}

				const as = targetElement.querySelectorAll("a[href]");
				for (const a of as) {
					const href = a.getAttribute('href');
					if (href == null || href == '') {
						continue;
					}

					if (href.startsWith('#')) {
						a.setAttribute('href', fixHash(href));
						continue;
					}

					const logicalHref = new URL(href, logicalBaseURL);
					if (logicalHref.pathname.endsWith('report.svg')) {
						a.href = 'report/report.svg';
						continue;
					} else if (!logicalHref.pathname.endsWith('.md')) {
						if (!href.startsWith('http')) {
							a.href = new URL(`https://github.com/${org}/${repo}/blob/${branch}/${path}/../${href}`);
						}
						continue;
					}

					const url = new URL(window.location);
					url.hash = fixHash(logicalHref.hash);
					if (logicalHref.hostname == 'api.github.com') {
						const parts = /\/repos\/(?<org>[^/]+)\/(?<repo>[^/]+)\/contents\/(?<path>.*)/.exec(logicalHref.pathname);
						if (parts != null) {
							if (parts.groups.org == 'eclipse-simrel' || parts.groups.org == 'eclipse-packaging') {
								url.search = getMarkdownSearch(`${parts.groups.org}/${parts.groups.repo}/${branch}/${parts.groups.path}`);
								a.href = url;
							}
						}
					} else if (logicalHref.hostname == 'github.com') {
						const parts = /(?<org>[^/]+)\/(?<repo>[^/]+)\/blob\/(?<branch>[^/]+)\/(?<path>.*)/.exec(logicalHref.pathname);
						if (parts != null) {
							if (parts.groups.org == 'eclipse-simrel' || parts.groups.org == 'eclipse-packaging') {
								url.search = getMarkdownSearch(`${parts.groups.org}/${parts.groups.repo}/${parts.groups.branch}/${parts.groups.path}`);
								a.href = url;
							}
						}
					}
				}

				const editMarkdownLink = document.getElementById('edit-markdown-link');
				if (editMarkdownLink != null) {
					editMarkdownLink.href = `https://github.com/${org}/${repo}/blob/${branch}/${path}`;
				}

				// Ensure that we nagivate to the target.
				if (document.location.hash.includes('#')) {
					document.location.hash = document.location.hash;
				}

				updateTocSize();
			}
		}

		generateBreadcrumbDetails(path.replace(/\/$/, ''));

		const logicalBaseURL = new URL(`https://api.github.com/repos/${org}/${repo}/contents/${path}`);
		const apiURL = `${logicalBaseURL}?ref=${branch}`;
		const defaultURL = selfHosted ? `${scriptBase}${path}` : apiURL;

		const localURL = new URL(file, window.location);
		// defaultURL = localURL.toString();

		function defaultHandler(url) {
			fetch(url).then(response => {
				return response.text();
			}).then(text => {
				if (text.startsWith('<') && !url.toString().endsWith('.md')) {
					if (text.startsWith('<img') || text.match(/<ul><li><a href="[^"]+"> Parent Directory<\/a><\/li>/)) {
						const links = [...text.matchAll(/href="([^./][^"]+?(\.md|\/))"/g).map(match => {
							return {url: `https://api.github.com/repos/${org}/${repo}/contents/${path}/${match[1]}?ref=${branch}`};
						})];
						generateFileList(links);
					} else if (url != apiURL) {
						targetElement.innerHTML = `Cannot produce directory listing ${url} redirecting to ${apiURL}.`;
						defaultHandler(apiURL);
					} else {
						targetElement.innerHTML = `Cannot produce directory listing ${url}.`;
					}
				} else if (text.startsWith('{') || text.startsWith('[')) {
					if (url.toString().endsWith('.json')) {
						generateMarkdown(logicalBaseURL, text);
					} else {
						const json = JSON.parse(text);
						generateMarkdown(logicalBaseURL, json instanceof Array ? json : blobToText(json.content));
					}
				} else {
					generateMarkdown(logicalBaseURL, text);
				}
			});
		}

		if (!selfHosted && isLocalHost) {
			const localURL = new URL(window.location);
			localURL.hash = '';
			localURL.search = '';
			localURL.pathname = `${org}/${repo}/${branch}/${path}`;
			fetch(localURL, {method: 'HEAD', cache: "no-store"}).then(response => {
				if (response.status == 200 && response.headers.get('Server') == 'org.eclipse.oomph.internal.util.HTTPServer') {
					defaultHandler(localURL);
				} else {
					defaultHandler(defaultURL);
				}
			});
		} else {
			defaultHandler(defaultURL);
		}

		function updateTocSize() {
			const toc = document.getElementById('toc');
			const tocInner = document.getElementById('table-of-contents');
			if (toc != null && tocInner != null) {
				const height = window.document.documentElement.clientHeight;
				tocInner.style.maxHeight = `${height - tocInner.getBoundingClientRect().top - 20}px`;
				toc.style.maxHeight = `${height - toc.getBoundingClientRect().top - 20}px`;
			}
		}

		const onscroll = window.onscroll;
		window.onscroll = function (event) {
			if (onscroll != null) {
				onscroll(event);
			}
			updateTocSize();
		};
		window.onresize = updateTocSize;

		//]]>
	</script>

</body>